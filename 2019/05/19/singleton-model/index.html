<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    单例模式 | TEAPER
  </title>
  <meta name="description" content="与人为善是修养，独来独往是性格！">
  
  <meta name="keywords" content="
  java
  ">
  
  <meta name="author" content="teaper">

  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://i.loli.net/2019/06/04/5cf683cea837456459.jpeg">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/live2d/css/live2d.css">
  <link rel="stylesheet" href="/css/player.css">
  <link rel="stylesheet" href="/iconfont/iconfont.css">
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-140493383-1', 'auto');
  ga('send', 'pageview');
</script>


  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
</head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <!-- <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div> -->

		<div class="navbar-search-form">
		  <label for="gsc-i-id1">THIS WEBSITE</label>
          <div id="site_search">
        	<input type="text" id="local-search-input" style results="0">
          </div>
        </div>
		
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li><a href="/links">Links</a></li>
        
		
        <li><a href="http://139.180.202.71/" target="_blank" rel="external nofollow noopener noreferrer">Files</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://i.loli.net/2019/06/04/5cf683cea837456459.jpeg"> <i class="fa fa-caret-down"></i></a>
        </li>
      </ul>
	  <!-- 站内搜索结果 -->
	  <br>
      <div id="local-search-result"></div>

    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i class="fa fa-file-text"></i> Posts </a>
        <a href="/archives" class="header-toolbar-right"> 20 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i class="fa fa-tags"></i> Tags </a>
        <a href="/tags" class="header-toolbar-right"> 49 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories" class="header-toolbar-right"> 11 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">TEAPER</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    teaper

    <span class="post-date float-right" title="{{moment(1558277311000).format('MMM DD, YYYY, h:mm:ss A')}}">
      <i class="fa fa-pencil-square-o"></i>
      {{moment(1558277311000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1 style="text-align:center">单例模式</h1>
    <p><span style="color:#B900ff;">核心作用：保证一个类只有一个示例，并且提供一个访问该实例的全局访问点</span>  </p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<p>Windows的Task Manager（任务管理器）就是典型的单例模式<br>Windows的Recycle Bin（回收站）也是典型的单例模式，在整个系统中，回收站一直维护着一个实例<br><span style="color:#ff0000;">项目中，读取配置文件的类，一般也只有一个对象，没有必要每次使用配置文件数据，每次new一个对象去读取</span><br>网站的计数器，一般也采用单例模式，否则难以同步<br>应用程序的日志功能，一般都使用单例模式，由于共享的日志文件一直处于打开状态，因为只能一个实例去操作，否则内容不好追加<br><span style="color:#ff0000;">数据库连接池的设计一般也采用单例模式，因为数据库连接是一种数据库资源</span><br>操作系统的文件系统，也是最大的单例模式的具体例子，一个操作系统只能有一个文件系统<br>Application 也是单例的典型应用（servlet 编程中会涉及到）<br><span style="color:#ff0000;">在Spring框架中，每个bean默认就是单例的，这样做的优点就是方便Spring IOC容器进行管理</span><br>在servlet编程中，每个servlet也是单例<br><span style="color:#ff0000;">在Spring MVC框架/struts2框架中，控制器对象也是单例</span>  </p>
</blockquote>
<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><p>由于单例模式只生成一个实例，减少系统性能开销，当一个对象的产生需要比较多的资源时（例如：读取配置、产生其他依赖对象时），则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决  </p>
<p>单例模式可以在系统设置全局的访问点，优化环共享资源访问（例如：可以设计一个单例类，负责所有数据表的映射处理）  </p>
<h4 id="常见的五种单例模式实现方式："><a href="#常见的五种单例模式实现方式：" class="headerlink" title="常见的五种单例模式实现方式："></a>常见的五种单例模式实现方式：</h4><p>主要：  </p>
<ul>
<li>饿汉式（线程安全，调用效率高；但是，不能延时加载）  </li>
<li>懒汉式（线程安全，调用效率不高；但是，可以延时加载）  </li>
</ul>
<p>其他：  </p>
<ul>
<li>双重检测锁式（用于JVM底层内部模型原因，偶尔出现问题，<span style="color:#ff0000;">不建议使用</span>）  </li>
<li>静态内部类式（线程安全，调用效率高，可以延时加载）</li>
<li>枚举式（线程安全，调用率高，不能延时加载，并且天然的防止反射和反序列化漏洞）  </li>
</ul>
<h4 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】饿汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> * 解说：</span></span><br><span class="line"><span class="comment"> * 类初始化的时候，不管你要不要都提供一个静态的私有对象instance</span></span><br><span class="line"><span class="comment"> * 静态变量会在类装载时初始化，此时不会涉及，多个线程对象的访问该对象的问题</span></span><br><span class="line"><span class="comment"> * 虚拟机保证只转载一次该类，肯定不会发生并发访问的问题，因此可以省略synchronized关键字</span></span><br><span class="line"><span class="comment"> * 再私有化构造器，不让创建其他对象 </span></span><br><span class="line"><span class="comment"> * 只提供静态私有方法返回仅有的一个对象instance</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 如果只是加载类，不调用类的getInstance()方法，会造成资源浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo01</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、只留一个私有的对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/*final*/</span> SingletonDemo01 instance= <span class="keyword">new</span> SingletonDemo01();	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;		</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、提供私有方法返回私有对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/*synchronized*/</span> <span class="function">SingletonDemo01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> * 解说：</span></span><br><span class="line"><span class="comment"> * 类初始化的时候，只创建静态的私有对象instance，并没有进行初始化(默认值：null)</span></span><br><span class="line"><span class="comment"> * 虚拟机保证只转载一次该类，肯定不会发生并发访问的问题，因此可以省略synchronized关键字</span></span><br><span class="line"><span class="comment"> * 再私有化构造器，不让创建其他对象 </span></span><br><span class="line"><span class="comment"> * 提供静态私有方法，判断是否初始化，如果未初始化就给对象进行初始化（延时加载、懒加载、真正用的时候才加载）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 资源利用率高了，而且每次调用getInstance()方法都要等待其他对象调用完，并发效率低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo02</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、创建一个静态私有对象，但是不初始化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo02 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、提供静态私有方法，判断是否初始化，如果未初始化就给对象进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> SingletonDemo02();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重检测锁式实现"><a href="#双重检测锁式实现" class="headerlink" title="双重检测锁式实现"></a>双重检测锁式实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】双重检测锁式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> * 解说：</span></span><br><span class="line"><span class="comment"> * 这个模式同步内容下方到if内部，提高了执行的效率</span></span><br><span class="line"><span class="comment"> * 不必每次获取对象时都进行同步，只有第一次才同步创建了以后就没必要</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 由于编译器优化原因和JVM底层内部模型原因，偶尔会出现问题，所以不建议使用（仅做参考）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo03</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、创建一个静态私有对象，但是不初始化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo03 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo03 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			SingletonDemo03 sc;</span><br><span class="line">			<span class="keyword">synchronized</span> (SingletonDemo03.class) &#123; </span><br><span class="line">				sc = instance;</span><br><span class="line">				<span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (SingletonDemo03.class) &#123;</span><br><span class="line">						<span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">							sc = <span class="keyword">new</span> SingletonDemo03();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					instance = sc;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态内部类式实现"><a href="#静态内部类式实现" class="headerlink" title="静态内部类式实现"></a>静态内部类式实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】静态内部类式（懒加载）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> * 解说：</span></span><br><span class="line"><span class="comment"> * 外部类没有static属性，则不会像饿汉式那样立刻加载对象</span></span><br><span class="line"><span class="comment"> * 初始化SingletonDemo04类的时候，并不会立即初始化它的静态内部类  </span></span><br><span class="line"><span class="comment"> * 只有调用getInstance()方法，才会调用它的静态内部类去创建实例对象，实现延时加载（懒加载）</span></span><br><span class="line"><span class="comment"> * 加载类时是线程安全的，instance对象是static final类型，保证内存中只有一个实例存在，而且只能被赋值一次，从而保证线程安全</span></span><br><span class="line"><span class="comment"> * 兼并了并发高效调用和延时加载的优势</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo04</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在静态内部类SingletonClassInstance中定义一个对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo04 instance = <span class="keyword">new</span> SingletonDemo04();	<span class="comment">//使用final禁止修改</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo04</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、提供静态私有方法，返回内部类实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo04 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonDemo04.SingletonClassInstance.instance;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举式实现"><a href="#枚举式实现" class="headerlink" title="枚举式实现"></a>枚举式实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】枚举单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 实现简单</span></span><br><span class="line"><span class="comment"> * 枚举本身就是单例模式，由JVM从根本上提供保障，避免了反射和反序列化的漏洞，调用效率比较高</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 没有延时加载（懒加载）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo05 &#123;</span><br><span class="line">	<span class="comment">// 枚举元素本身就是单例对象，定义一个枚举的元素，它就代表单例的一个实例</span></span><br><span class="line">	INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加自己需要的操作。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//功能处理代码块</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:#ff0000;">那么如何选用呢？</span><br>如果是单例对象，要求占用资源少，不需要延时加载的话</p>
<ul>
<li><strong>枚举式</strong> 好于 <strong>饿汉式</strong>  </li>
</ul>
<p>如果是单例对象，要求占用资源大，需要延时加载的话</p>
<ul>
<li><strong>静态内部类式</strong> 好于 <strong>懒汉式</strong>  </li>
</ul>
<h4 id="破解单例模式"><a href="#破解单例模式" class="headerlink" title="破解单例模式"></a>破解单例模式</h4><p>虽然说单例模式被我们设计成只有一个对象，不过我们依然可以使用<strong>反射</strong>、<strong>反序列化</strong>破解除枚举之外的其他四种单例模式，让它创建多个对象  </p>
<blockquote>
<p>使用反射破解懒汉式  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】使用反射和反序列化破解单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//先输出两个懒汉式对象的值</span></span><br><span class="line">		SingletonDemo06 instance1 = SingletonDemo06.getInstance();</span><br><span class="line">		SingletonDemo06 instance2 = SingletonDemo06.getInstance();</span><br><span class="line">		System.out.println(instance1+<span class="string">"\n"</span>+instance2);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用反射破解懒汉式</span></span><br><span class="line">		Class&lt;SingletonDemo06&gt; clazz =  (Class&lt;SingletonDemo06&gt;) Class.forName(<span class="string">"cn.teaper.www.singletonmode.SingletonDemo06"</span>);</span><br><span class="line">		Constructor&lt;SingletonDemo06&gt; c = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">		c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		SingletonDemo06 s3 = c.newInstance();</span><br><span class="line">		SingletonDemo06 s4 = c.newInstance();</span><br><span class="line">		System.out.println(s3+<span class="string">"\n"</span>+s4);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先输出<code>instance1</code>和<code>instance2</code>的值，确定是同一个对象，然后使用反射破解懒汉式，再输出两个对象，可以发现运行结果变成  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cn.teaper.www.singletonmode.SingletonDemo06@7b3300e5    <span class="comment">#instance1</span></span><br><span class="line">cn.teaper.www.singletonmode.SingletonDemo06@7b3300e5    <span class="comment">#instance2</span></span><br><span class="line">cn.teaper.www.singletonmode.SingletonDemo06@2e5c649     <span class="comment">#s3</span></span><br><span class="line">cn.teaper.www.singletonmode.SingletonDemo06@136432db    <span class="comment">#s4</span></span><br></pre></td></tr></table></figure>

<p>很明显利用反射可以直接破解懒汉式，那么<strong>如何防止懒汉式被破解呢？</strong><br>可以判断对象是否存在，不存在则<strong>抛出运行时异常</strong>，就此防止懒汉式被破解  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】测试懒汉式（如何防止反射和反序列化漏洞）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo06</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo06 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//抛出异常防止反射破解</span></span><br><span class="line">		<span class="keyword">if</span>(instance!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo06 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> SingletonDemo06();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用反序列化破解懒汉式  </p>
</blockquote>
<p>要使用反射，首先懒汉式的类就要继承<code>Serializable</code>类  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】测试懒汉式（如何防止反射和反序列化漏洞）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo06</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;   <span class="comment">//继承Serializable类</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1、创建一个静态私有对象，但是不初始化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo06 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、提供静态私有方法，判断是否初始化，如果未初始化就给对象进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo06 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> SingletonDemo06();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先使用序列化将值存储在<code>a.txt</code>中，然后再进行反序列化输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】使用反射和反序列化破解懒汉式单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//先输出两个懒汉式对象的值</span></span><br><span class="line">		SingletonDemo06 instance1 = SingletonDemo06.getInstance();</span><br><span class="line">		SingletonDemo06 instance2 = SingletonDemo06.getInstance();</span><br><span class="line">		System.out.println(instance1+<span class="string">"\n"</span>+instance2);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用反序列化破解懒汉式</span></span><br><span class="line">		<span class="comment">//序列化</span></span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"../a.txt"</span>);</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">		oos.writeObject(instance1);</span><br><span class="line">		oos.close();</span><br><span class="line">		fos.close();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//反序列化</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"../a.txt"</span>));</span><br><span class="line">		SingletonDemo06 s3 = (SingletonDemo06) ois.readObject();</span><br><span class="line">		System.out.println(s3);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到输出结果是不同的  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cn.teaper.www.singletonmode.SingletonDemo06@7b3300e5    <span class="comment">#instance1</span></span><br><span class="line">cn.teaper.www.singletonmode.SingletonDemo06@7b3300e5    <span class="comment">#instance2</span></span><br><span class="line">cn.teaper.www.singletonmode.SingletonDemo06@7cf10a6f    <span class="comment">#s3</span></span><br></pre></td></tr></table></figure>

<p>那么如何<strong>防止被反序列化破解</strong>呢？<br>只需要添加一个私有方法<code>reaObject()</code>返回instance对象即可  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】测试懒汉式（如何防止反射和反序列化漏洞）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo06</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1、创建一个静态私有对象，但是不初始化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo06 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//抛出异常破解反射</span></span><br><span class="line">		<span class="keyword">if</span>(instance!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、提供静态私有方法，判断是否初始化，如果未初始化就给对象进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo06 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> SingletonDemo06();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//防止反序列化破解</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">reaObject</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;<span class="comment">//在反序列化时会直接调用reaObject()方法返回instance对象，而不会把反序列化的新对象返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五种单例模式的执行效率"><a href="#五种单例模式的执行效率" class="headerlink" title="五种单例模式的执行效率"></a>五种单例模式的执行效率</h4><p>这里我们采用的是多线程下进行的测试，不同环境下的值有所不同  </p>
<table>
<thead>
<tr>
<th>单例模式</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>饿汉式</td>
<td>22ms</td>
</tr>
<tr>
<td>懒汉式</td>
<td>636ms</td>
</tr>
<tr>
<td>静态内部类式</td>
<td>28ms</td>
</tr>
<tr>
<td>枚举式</td>
<td>32ms</td>
</tr>
<tr>
<td>双重检测锁式</td>
<td>65ms</td>
</tr>
</tbody></table>
<p>要测试多线程下单例模式的执行效率，需要借助一个<code>CountDownLatch</code>类  </p>
<blockquote>
<p>同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待<br><code>countDown()</code>当前线程调用此方法，则计数减一（建议放在finally里执行）<br><code>await()</code>调用此方法会一直阻塞当前线程，直到倒计时为零  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【单例模式】测试多线程模式下五种单例模式的执行效率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> teaper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">						Object o = SingletonDemo02.getInstance();<span class="comment">//SingletonDemo01可以换成你想要测试的单例类</span></span><br><span class="line">					&#125;</span><br><span class="line">					countDownLatch.countDown();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">		countDownLatch.await();<span class="comment">//线程阻塞，直到计数器为0，才继续往下执行</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"总耗时："</span>+(end-start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </article>
</div>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<div class="container" id="gitalk-container"></div>
<script>
    var gitalk = new Gitalk({
        clientID: '79a82d93fcd761032f45',
        clientSecret: 'b784392d66d81a991565a56598f2d369e71e21ad',
        repo: 'hexoblog',
        owner: 'teaper',
        admin: ['teaper'],
	id: md5(location.pathname),
        distractionFreeMode: true
    })
    gitalk.render('gitalk-container')
</script>




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="https://www.teaper.dev" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 teaper</li>
      <li><a href="https://www.teaper.dev">Home</a></li>
      
      <li><a href="https://github.com/teaper" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li>
      
      <li><a href="https://www.weibo.com/5806191772" rel="external nofollow noopener noreferrer" target="_blank">Weibo</a></li>
      
      <li><a href="https://twitter.com/TEAPERS" rel="external nofollow noopener noreferrer" target="_blank">Twitter</a></li>
      
    </ul>
    <div class="footer-theme-info" id="hitokoto">
       行是知之始 ❤ 知是行之成
    </div>
    </div>
    
    <div class="footer-pageview">
        <a href="https://info.flagcounter.com/MrmG" rel="external nofollow noopener noreferrer" target="_blank">
          <img src="https://s04.flagcounter.com/count2/MrmG/bg_FFFFFF/txt_6A737D/border_FFFFFF/columns_7/maxflags_14/viewers_3/labels_1/pageviews_1/flags_0/percent_0/">
        </a>
    </div>
    
  </footer>
</div>
<!-- QPlayer音乐播放器 -->
<div id="QPlayer">
<div id="pContent">
	<div id="player">
		<span class="cover"></span>
		<div class="ctrl">
			<div class="musicTag marquee">
				<strong>Title</strong>
				 <span> - </span>
				<span class="artist">Artist</span>
			</div>
			<div class="progress">
				<div class="timer left">0:00</div>
				<div class="contr">
					<div class="rewind icon"></div>
					<div class="playback icon"></div>
					<div class="fastforward icon"></div>
				</div>
				<div class="right">
					<div class="liebiao icon"></div>
				</div>
			</div>
		</div>
	</div>
	<div class="ssBtn">
	        <div class="adf"></div>
    </div>
</div>
<ol id="playlist"></ol>
</div>
<!-- <script src="js/jquery.min.js"></script> -->
<!-- <script src="js/jquery.marquee.min.js"></script> -->
<script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/jquery.marquee/1.4.0/jquery.marquee.min.js"></script>

<script src="/js/playlist.js"></script>
<script src="/js/player.js"></script>
<script>
function bgChange(){
	var lis= $('.lib');
	for(var i=0; i<lis.length; i+=2)
	lis[i].style.background = 'rgba(246, 246, 246, 0.5)';
	
	$(".avatar").hover(function(){
		$(".avatar").attr({
		"src" : "http://ww1.sinaimg.cn/large/006kWbIoly1g763f4h9w5j30np0np40j.jpg"
		});
	},function(){
		$(".avatar").attr({
		"src" : "https://i.loli.net/2019/06/04/5cf683cea837456459.jpeg"
		});
	});
}
window.onload = bgChange;
</script>

<!-- Live2D血小板 -->
<div id="landlord">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="560" height="500" class="live2d"></canvas>
    <!-- 省略隐藏按钮 -->
</div>

<!-- 鼠标单击爆炸区域 -->
<canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1031;pointer-events:none;"></canvas>

<script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script type="text/javascript">
    var message_Path = '/live2d/'
    var home_Path = 'https://www.teaper.dev/'
</script>
<script type="text/javascript" src="/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/live2d/js/message.js"></script>
<script type="text/javascript">
    loadlive2d("live2d", "/live2d/model/xiaoban/model.json");
</script>

<!-- 打字泡沫 -->
<script type="text/javascript" src="/js/activate-power-mode.js"></script>
<script>
    POWERMODE.colorful = true;  
    POWERMODE.shake = false;    
    document.body.addEventListener('input', POWERMODE);
</script>

<!-- 引入一言 -->
<script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
<script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script>
<!-- <script src="/js/hitokoto.js"></script> -->

<!-- 粒子特效 -->
<!-- <script src="/js/canvas-nest.min.js"></script> -->

<!-- 鼠标单击爱心特效 -->
<script src="/js/mouse.js"></script>
<!-- 鼠标单击爆炸特效 -->
<script src="/js/anime.min.js"></script>
<script src="/js/fireworks.js"></script>

<!-- 站内搜索 -->
<script src="/js/search.js"></script>



<script>
  (function() {
    var cx = '014633199185561276043:bpv9wnr4qhc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
      '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>



<script src="/js/main.js"></script>

</body>
</html>
